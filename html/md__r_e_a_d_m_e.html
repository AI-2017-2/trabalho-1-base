<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Métodos de Busca no Pacman: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Métodos de Busca no Pacman
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="docs/maze.png" alt="pacman maze"/>
</div>
 <h1>Trabalho 1. Métodos de Busca no PacMan</h1>
<blockquote class="doxtable">
<p><b>Notice to mariners:</b> Based on Pacman search problems originally from <a href="http://inst.eecs.berkeley.edu/~cs188/">Berkeley AI CS 188</a>. Original code has been ported to Python 3.x. </p>
</blockquote>
<h2>Introdução</h2>
<p>Neste trabalho, o agente Pacman tem que encontrar caminhos no labirinto, tanto para chegar a um destino quanto para coletar comida eficientemente. O objetivo do trabalho será programar algoritmos de busca e aplicá-los ao cenário do Pacman. O código desse trabalho consiste de diversos arquivos Python, alguns dos quais você terá que ler e entender para fazer o trabalho.</p>
<p>Arquivos que devem ser editados:</p>
<ul>
<li><code>search.py</code> - Onde ficam os algoritmos de busca.</li>
<li><code>searchAgents.py</code> - Onde ficam os agentes baseados em busca.</li>
</ul>
<p>Arquivos que devem ser lidos:</p>
<ul>
<li><code>pacman.py</code> - O arquivo principal que roda jogos de Pacman. Esse arquivo também descreve o tipo <code>GameState</code>, que será amplamente usado nesse trabalho.</li>
<li><code>game.py</code> - A lógica do mundo do Pacman. Este arquivo descreve vários tipos auxiliares como <code>AgentState</code>, <code>Agent</code>, <code>Direction</code> e <code>Grid</code>.</li>
<li><code>util.py</code> - Estruturas de dados úteis para implementar algoritmos de busca.</li>
</ul>
<p>Arquivos que podem ser ignorados:</p>
<ul>
<li><code>graphicsDisplay.py</code> - Visualização gráfica do Pacman</li>
<li><code>graphicsUtils.py</code> - Funções auxiliares para visualização gráfica do Pacman</li>
<li><code>textDisplay.py</code> - Visualização gráfica em ASCII para o Pacman</li>
<li><code>ghostAgents.py</code> - Agentes para controlar fantasmas</li>
<li><code>keyboardAgents.py</code> - Interfaces de controle do Pacman a partir do teclado</li>
<li><code>layout.py</code> - Código para ler arquivos de layout e guardar seu conteúdo</li>
</ul>
<p>O que deve ser entregue:</p>
<ul>
<li>Os arquivos <code>search.py</code> e <code>searchAgents.py</code> serão modificados no trabalho.</li>
</ul>
<p>Cada grupo deve entregar esses dois arquivos e deve entregar também um relatório impresso respondendo as perguntas listadas abaixo. Cada grupo deve ser composto de 2 ou 3 alunos.</p>
<p>Bem-vindo ao Pacman</p>
<p>Depois de baixar o código (search.zip), descompactá-lo e entrar no diretório search, você pode jogar um jogo de Pacman digitando a seguinte linha de comando:</p>
<div class="fragment"><div class="line">python pacman.py</div></div><!-- fragment --><p>O agente mais simples em <code>searchAgents.py</code> é o agente <code>GoWestAgent</code>, que sempre vai para oeste (um agente reflexivo trivial). Este agente pode ganhar às vezes:</p>
<div class="fragment"><div class="line">python pacman.py --layout testMaze --pacman GoWestAgent</div></div><!-- fragment --><p>Mas as coisas se tornam mais difíceis quando virar é necessário:</p>
<div class="fragment"><div class="line">python pacman.py --layout tinyMaze --pacman GoWestAgent</div></div><!-- fragment --><p><code>pacman.py</code> tem opções que podem ser dadas em formato longo (por exemplo, <code>--layout</code>) ou em formato curto (por exemplo, <code>-l</code>). A lista de todas as opções pode ser vista executando:</p>
<div class="fragment"><div class="line">python pacman.py -h</div></div><!-- fragment --><p>Todos os comandos que aparecem aqui também estão em <code>commands.txt</code>, e podem ser copiados e colados.</p>
<p>Encontrando comida em um ponto fixo usando algoritmos de busca</p>
<p>No arquivo <code>searchAgents.py</code>, você irá encontrar o programa de um agente de busca (<code>SearchAgent</code>), que planeja um caminho no mundo do Pacman e executa o caminho passo-a-passo. Os algoritmos de busca para planejar o caminho não estão implementados &ndash; este será o seu trabalho.</p>
<p>Para entender o que está descrito a seguir, pode ser necessário olhar esse glossário de objetos. Primeiro, verifique que o agente de busca SearchAgent está funcionando corretamente, rodando:</p>
<div class="fragment"><div class="line">python pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch</div></div><!-- fragment --><p>O comando acima faz o agente <code>SearchAgent</code> usar o algoritmo de busca <code>tinyMazeSearch</code>, que está implementado em <code>search.py</code>. O Pacman deve navegar o labirinto corretamente.</p>
<p>Agora chegou a hora de implementar os seus algoritmos de busca para o Pacman! Os pseudocódigos dos algoritmos de busca estão no livro.</p>
<p>Lembre-se que um nó da busca deve conter não só o estado mas também toda a informação necessária para reconstruir o caminho (sequência de ações) até aquele estado.Importante: Todas as funções de busca devem retornar uma lista de ações que irão levar o agente do início até o objetivo. Essas ações devem ser legais (direções válidas, sem passar pelas paredes).</p>
<p><em>Dica 1:</em> Os algoritmos de busca são muito parecidos. Os algoritmos de busca em profundidade, busca em extensão, busca de custo uniforme e A* diferem somente na ordem em que os nós são retirados da borda. Então o ideal é tentar implementar a busca em profundidade corretamente e depois será mais fácil implementar as outras. Uma possível implementação é criar um algoritmo de busca genérico que possa ser configurado com uma estratégia para retirar nós da borda. (Porém, implementar dessa forma não é necessário).</p>
<p><em>Dica 2:</em> Dê uma olhada no código dos tipo <code>Stack</code> (pilha), <code>Queue</code> (fila) e <code>PriorityQueue</code> (fila com prioridade) que estão no arquivo <code>util.py</code>.</p>
<h2>Etapa 1 (2 pontos)</h2>
<p>Implemente o algoritmo de busca em profundidade (DFS) na função <code>depthFirstSearch()</code> do arquivo <code>search.py</code>. Para que a busca seja completa, implemente a versão de DFS que não expande estados repetidos (seção 3.5 do livro).</p>
<p>Teste seu código executando:</p>
<div class="fragment"><div class="line">python pacman.py -l tinyMaze -p SearchAgent</div><div class="line">python pacman.py -l mediumMaze -p SearchAgent</div><div class="line">python pacman.py -l bigMaze -z .5 -p SearchAgent</div></div><!-- fragment --><p>A saída do Pacman irá mostrar os estados explorados e a ordem em que eles foram explorados (vermelho mais forte significa que o estado foi explorado antes).</p>
<ul>
<li><b>Pergunta 1:</b> A ordem de exploração foi de acordo com o esperado? O Pacman realmente passa por todos os estados explorados no seu caminho para o objetivo?Dica: Se você usar a pilha Stack como estrutura de dados, a solução encontrada pelo algoritmo DFS para o mediumMaze deve ter comprimento 130 (se os sucessores forem colocados na pilha na ordem dada por getSuccessors; pode ter comprimento 246 se forem colocados na ordem reversa). (Pergunta 2) Essa é uma solução ótima? Senão, o que a busca em profundidade está fazendo de errado?</li>
</ul>
<h2>Etapa 2 (2 pontos)</h2>
<p>Implemente o algoritmo de busca em extensão (BFS) na função <code>breadthFirstSearch</code> do arquivo <code>search.py</code>. De novo, implemente a versão que não expande estados que já foram visitados. Teste seu código executando:</p>
<div class="fragment"><div class="line">python pacman.py -l mediumMaze -p SearchAgent -a fn=bfs</div><div class="line">python pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5</div></div><!-- fragment --><ul>
<li><b>Pergunta 3:</b> A busca BFS encontra a solução ótima? Senão, verifique a sua implementação. Se o seu código foi escrito de maneira correta, ele deve funcionar também para o quebra-cabeças de 8 peças (seção 3.2 do livro-texto) sem modificações.</li>
</ul>
<div class="fragment"><div class="line">python eightpuzzle.py</div></div><!-- fragment --><p>A busca BFS vai encontrar o caminho com o menor número de ações até o objetivo. Porém, podemos querer encontrar caminhos que sejam melhores de acordo com outros critérios. Considere o labirinto mediumDottedMaze e o labirinto mediumScaryMaze. Mudando a função de custo, podemos fazer o Pacman encontrar caminhos diferentes. Por exemplo, podemos ter custos maiores para passar por áreas com fantasmas e custos menores para passar em áreas com comida, e um agente Pacman racional deve poder ajustar o seu comportamento.</p>
<h2>Etapa 3 (2 pontos)</h2>
<p>Implemente o algoritmo de busca de custo uniforme (checando estados repetidos) na função <code>uniformCostSearch</code> do arquivo <code>search.py</code>. Teste seu código executando os comandos a seguir, onde os agentes tem diferentes funções de custo (os agentes e as funções são dados):</p>
<div class="fragment"><div class="line">python pacman.py -l mediumMaze -p SearchAgent -a fn=ucs</div><div class="line">python pacman.py -l mediumDottedMaze -p StayEastSearchAgent</div><div class="line">python pacman.py -l mediumScaryMaze -p StayWestSearchAgentA* search</div></div><!-- fragment --><h2>Etapa 4 (2 pontos)</h2>
<p>Implemente a busca A* (com checagem de estados repetidos) na função <code>StarSearch</code> do arquivo <code>search.py</code>. A busca A* recebe uma heurística como parâmetro.</p>
<p>Heurísticas têm dois parâmetros: um estado do problema de busca (o parâmetro principal), e o próprio problema. A heurística implementada na função <code>nullHeuristic</code> do arquivo <code>search.py</code> é um exemplo trivial.</p>
<p>Teste sua implementação de A* no problema original de encontrar um caminho através de um labirinto para uma posição fixa usando a heurística de distância Manhattan (implementada na função <code>manhattanHeuristic</code> do arquivo <code>searchAgents.py</code>).</p>
<div class="fragment"><div class="line">python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic</div></div><!-- fragment --><p>A busca A* deve achar a solução ótima um pouco mais rapidamente que a busca de custo uniforme (549 vs. 621 nós de busca expandidos na nossa implementação).</p>
<h1>Coletando comida</h1>
<p>Agora iremos atacar um problema mais difícil: fazer o Pacman comer toda a comida no menor número de passos possível. Para isso, usaremos uma nova definição de problema de busca que formaliza esse problema: <code>FoodSearchProblem</code> no arquivo <code>searchAgents.py</code> (já implementado). Uma solução é um caminho que coleta toda a comida no mundo do Pacman. A solução não será modificada se houverem fantasmas no caminho; ela só depende do posicionamento das paredes, da comida e do Pacman. Se os seus algoritmos de busca estiverem corretos, A* com uma heurística nula (equivalente a busca de custo uniforme) deve encontrar uma solução para o problema testSearch sem nenhuma mudança no código (custo total de 7).</p>
<div class="fragment"><div class="line">python pacman.py -l testSearch -p AStarFoodSearchAgent</div></div><!-- fragment --><p><em>Nota:</em> <code>AStarFoodSearchAgent</code> é um atalho para <code>-p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=foodHeuristic</code>. Porém, a busca de custo uniforme fica lenta até para problemas simples como <code>tinySearch</code>.</p>
<h2>Etapa 5 (2 pontos)</h2>
<p>Implemente uma heurística admissível <code>foodHeuristic</code> no arquivo <code>searchAgents.py</code> para o problema <code>FoodSearchProblem</code>. Teste seu agente no problema <code>trickySearch</code>:</p>
<div class="fragment"><div class="line">python pacman.py -l trickySearch -p AStarFoodSearchAgent</div></div><!-- fragment --> <h1>Glossário</h1>
<p>Este é um glossário dos objetos principais na base de código relacionada a problemas de busca:</p>
<ul>
<li><code>SearchProblem</code> (<code>search.py</code>): Um <code>SearchProblem</code> é um objeto abstrato que representa o espaço de estados, função sucessora, custos, e estado objetivo de um problema. Você vai interagir com objetos do tipo <code>SearchProblem</code> somente através dos métodos definidos no topo de <code>search.py</code>.</li>
<li><code>PositionSearchProblem</code> (<code>searchAgents.py</code>): Um tipo específico de <code>SearchProblem</code> &mdash; corresponde a procurar por uma única comida no labirinto.</li>
<li><code>FoodSearchProblem</code> (<code>searchAgents.py</code>): Um tipo específico de <code>SearchProblem</code> &mdash; corresponde a procurar um caminho para comer toda a comida em um labirinto.</li>
<li><b>Função de Busca:</b> Uma função de busca é uma função que recebe como entrada uma instância de <code>SearchProblem</code>, roda algum algoritmo, e retorna a sequência de ações que levam ao objetivo. Exemplos de função de busca são <code>depthFirstSearch</code> e <code>breadthFirstSearch</code>, que deverão ser escritas pelo grupo. A função de busca dada <code>tinyMazeSearch</code> é uma função muito ruim que só funciona para o labirinto <code>tinyMaze</code>.</li>
<li><code>SearchAgent</code>: é uma classe que implementa um agente (um objeto que interage com o mundo) e faz seu planejamento de acordo com uma função de busca. <code>SearchAgent</code> primeiro usa uma função de busca para encontrar uma sequência de ações que levem ao estado objetivo, e depois executa as ações uma por vez. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
