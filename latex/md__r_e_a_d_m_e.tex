 \section*{Trabalho 1. Métodos de Busca no Pac\+Man}

\begin{quote}
{\bfseries Notice to mariners\+:} Based on Pacman search problems originally from \href{http://inst.eecs.berkeley.edu/~cs188/}{\tt Berkeley AI CS 188}. Original code has been ported to Python 3.\+x. \end{quote}


\subsection*{Introdução}

Neste trabalho, o agente Pacman tem que encontrar caminhos no labirinto, tanto para chegar a um destino quanto para coletar comida eficientemente. O objetivo do trabalho será programar algoritmos de busca e aplicá-\/los ao cenário do Pacman. O código desse trabalho consiste de diversos arquivos Python, alguns dos quais você terá que ler e entender para fazer o trabalho.

Arquivos que devem ser editados\+:


\begin{DoxyItemize}
\item {\ttfamily search.\+py} -\/ Onde ficam os algoritmos de busca.
\item {\ttfamily search\+Agents.\+py} -\/ Onde ficam os agentes baseados em busca.
\end{DoxyItemize}

Arquivos que devem ser lidos\+:


\begin{DoxyItemize}
\item {\ttfamily pacman.\+py} -\/ O arquivo principal que roda jogos de Pacman. Esse arquivo também descreve o tipo {\ttfamily Game\+State}, que será amplamente usado nesse trabalho.
\item {\ttfamily game.\+py} -\/ A lógica do mundo do Pacman. Este arquivo descreve vários tipos auxiliares como {\ttfamily Agent\+State}, {\ttfamily Agent}, {\ttfamily Direction} e {\ttfamily Grid}.
\item {\ttfamily util.\+py} -\/ Estruturas de dados úteis para implementar algoritmos de busca.
\end{DoxyItemize}

Arquivos que podem ser ignorados\+:


\begin{DoxyItemize}
\item {\ttfamily graphics\+Display.\+py} -\/ Visualização gráfica do Pacman
\item {\ttfamily graphics\+Utils.\+py} -\/ Funções auxiliares para visualização gráfica do Pacman
\item {\ttfamily text\+Display.\+py} -\/ Visualização gráfica em A\+S\+C\+II para o Pacman
\item {\ttfamily ghost\+Agents.\+py} -\/ Agentes para controlar fantasmas
\item {\ttfamily keyboard\+Agents.\+py} -\/ Interfaces de controle do Pacman a partir do teclado
\item {\ttfamily layout.\+py} -\/ Código para ler arquivos de layout e guardar seu conteúdo
\end{DoxyItemize}

O que deve ser entregue\+:


\begin{DoxyItemize}
\item Os arquivos {\ttfamily search.\+py} e {\ttfamily search\+Agents.\+py} serão modificados no trabalho.
\end{DoxyItemize}

Cada grupo deve entregar esses dois arquivos e deve entregar também um relatório impresso respondendo as perguntas listadas abaixo. Cada grupo deve ser composto de 2 ou 3 alunos.

Bem-\/vindo ao Pacman

Depois de baixar o código (search.\+zip), descompactá-\/lo e entrar no diretório search, você pode jogar um jogo de Pacman digitando a seguinte linha de comando\+:


\begin{DoxyCode}
python pacman.py
\end{DoxyCode}


O agente mais simples em {\ttfamily search\+Agents.\+py} é o agente {\ttfamily Go\+West\+Agent}, que sempre vai para oeste (um agente reflexivo trivial). Este agente pode ganhar às vezes\+:


\begin{DoxyCode}
python pacman.py --layout testMaze --pacman GoWestAgent
\end{DoxyCode}


Mas as coisas se tornam mais difíceis quando virar é necessário\+:


\begin{DoxyCode}
python pacman.py --layout tinyMaze --pacman GoWestAgent
\end{DoxyCode}


{\ttfamily pacman.\+py} tem opções que podem ser dadas em formato longo (por exemplo, {\ttfamily -\/-\/layout}) ou em formato curto (por exemplo, {\ttfamily -\/l}). A lista de todas as opções pode ser vista executando\+:


\begin{DoxyCode}
python pacman.py -h
\end{DoxyCode}


Todos os comandos que aparecem aqui também estão em {\ttfamily commands.\+txt}, e podem ser copiados e colados.

Encontrando comida em um ponto fixo usando algoritmos de busca

No arquivo {\ttfamily search\+Agents.\+py}, você irá encontrar o programa de um agente de busca ({\ttfamily Search\+Agent}), que planeja um caminho no mundo do Pacman e executa o caminho passo-\/a-\/passo. Os algoritmos de busca para planejar o caminho não estão implementados -- este será o seu trabalho.

Para entender o que está descrito a seguir, pode ser necessário olhar esse glossário de objetos. Primeiro, verifique que o agente de busca Search\+Agent está funcionando corretamente, rodando\+:


\begin{DoxyCode}
python pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch
\end{DoxyCode}


O comando acima faz o agente {\ttfamily Search\+Agent} usar o algoritmo de busca {\ttfamily tiny\+Maze\+Search}, que está implementado em {\ttfamily search.\+py}. O Pacman deve navegar o labirinto corretamente.

Agora chegou a hora de implementar os seus algoritmos de busca para o Pacman! Os pseudocódigos dos algoritmos de busca estão no livro.

Lembre-\/se que um nó da busca deve conter não só o estado mas também toda a informação necessária para reconstruir o caminho (sequência de ações) até aquele estado.\+Importante\+: Todas as funções de busca devem retornar uma lista de ações que irão levar o agente do início até o objetivo. Essas ações devem ser legais (direções válidas, sem passar pelas paredes).

{\itshape Dica 1\+:} Os algoritmos de busca são muito parecidos. Os algoritmos de busca em profundidade, busca em extensão, busca de custo uniforme e A$\ast$ diferem somente na ordem em que os nós são retirados da borda. Então o ideal é tentar implementar a busca em profundidade corretamente e depois será mais fácil implementar as outras. Uma possível implementação é criar um algoritmo de busca genérico que possa ser configurado com uma estratégia para retirar nós da borda. (Porém, implementar dessa forma não é necessário).

{\itshape Dica 2\+:} Dê uma olhada no código dos tipo {\ttfamily Stack} (pilha), {\ttfamily Queue} (fila) e {\ttfamily Priority\+Queue} (fila com prioridade) que estão no arquivo {\ttfamily util.\+py}.

\subsection*{Etapa 1 (2 pontos)}

Implemente o algoritmo de busca em profundidade (D\+FS) na função {\ttfamily depth\+First\+Search()} do arquivo {\ttfamily search.\+py}. Para que a busca seja completa, implemente a versão de D\+FS que não expande estados repetidos (seção 3.\+5 do livro).

Teste seu código executando\+:


\begin{DoxyCode}
python pacman.py -l tinyMaze -p SearchAgent
python pacman.py -l mediumMaze -p SearchAgent
python pacman.py -l bigMaze -z .5 -p SearchAgent
\end{DoxyCode}


A saída do Pacman irá mostrar os estados explorados e a ordem em que eles foram explorados (vermelho mais forte significa que o estado foi explorado antes).


\begin{DoxyItemize}
\item {\bfseries Pergunta 1\+:} A ordem de exploração foi de acordo com o esperado? O Pacman realmente passa por todos os estados explorados no seu caminho para o objetivo?Dica\+: Se você usar a pilha Stack como estrutura de dados, a solução encontrada pelo algoritmo D\+FS para o medium\+Maze deve ter comprimento 130 (se os sucessores forem colocados na pilha na ordem dada por get\+Successors; pode ter comprimento 246 se forem colocados na ordem reversa). (Pergunta 2) Essa é uma solução ótima? Senão, o que a busca em profundidade está fazendo de errado?
\end{DoxyItemize}

\subsection*{Etapa 2 (2 pontos)}

Implemente o algoritmo de busca em extensão (B\+FS) na função {\ttfamily breadth\+First\+Search} do arquivo {\ttfamily search.\+py}. De novo, implemente a versão que não expande estados que já foram visitados. Teste seu código executando\+:


\begin{DoxyCode}
python pacman.py -l mediumMaze -p SearchAgent -a fn=bfs
python pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5
\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries Pergunta 3\+:} A busca B\+FS encontra a solução ótima? Senão, verifique a sua implementação. Se o seu código foi escrito de maneira correta, ele deve funcionar também para o quebra-\/cabeças de 8 peças (seção 3.\+2 do livro-\/texto) sem modificações.
\end{DoxyItemize}


\begin{DoxyCode}
python eightpuzzle.py
\end{DoxyCode}


A busca B\+FS vai encontrar o caminho com o menor número de ações até o objetivo. Porém, podemos querer encontrar caminhos que sejam melhores de acordo com outros critérios. Considere o labirinto medium\+Dotted\+Maze e o labirinto medium\+Scary\+Maze. Mudando a função de custo, podemos fazer o Pacman encontrar caminhos diferentes. Por exemplo, podemos ter custos maiores para passar por áreas com fantasmas e custos menores para passar em áreas com comida, e um agente Pacman racional deve poder ajustar o seu comportamento.

\subsection*{Etapa 3 (2 pontos)}

Implemente o algoritmo de busca de custo uniforme (checando estados repetidos) na função {\ttfamily uniform\+Cost\+Search} do arquivo {\ttfamily search.\+py}. Teste seu código executando os comandos a seguir, onde os agentes tem diferentes funções de custo (os agentes e as funções são dados)\+:


\begin{DoxyCode}
python pacman.py -l mediumMaze -p SearchAgent -a fn=ucs
python pacman.py -l mediumDottedMaze -p StayEastSearchAgent
python pacman.py -l mediumScaryMaze -p StayWestSearchAgentA* search
\end{DoxyCode}


\subsection*{Etapa 4 (2 pontos)}

Implemente a busca A$\ast$ (com checagem de estados repetidos) na função {\ttfamily Star\+Search} do arquivo {\ttfamily search.\+py}. A busca A$\ast$ recebe uma heurística como parâmetro.

Heurísticas têm dois parâmetros\+: um estado do problema de busca (o parâmetro principal), e o próprio problema. A heurística implementada na função {\ttfamily null\+Heuristic} do arquivo {\ttfamily search.\+py} é um exemplo trivial.

Teste sua implementação de A$\ast$ no problema original de encontrar um caminho através de um labirinto para uma posição fixa usando a heurística de distância Manhattan (implementada na função {\ttfamily manhattan\+Heuristic} do arquivo {\ttfamily search\+Agents.\+py}).


\begin{DoxyCode}
python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic
\end{DoxyCode}


A busca A$\ast$ deve achar a solução ótima um pouco mais rapidamente que a busca de custo uniforme (549 vs. 621 nós de busca expandidos na nossa implementação).

\section*{Coletando comida}

Agora iremos atacar um problema mais difícil\+: fazer o Pacman comer toda a comida no menor número de passos possível. Para isso, usaremos uma nova definição de problema de busca que formaliza esse problema\+: {\ttfamily Food\+Search\+Problem} no arquivo {\ttfamily search\+Agents.\+py} (já implementado). Uma solução é um caminho que coleta toda a comida no mundo do Pacman. A solução não será modificada se houverem fantasmas no caminho; ela só depende do posicionamento das paredes, da comida e do Pacman. Se os seus algoritmos de busca estiverem corretos, A$\ast$ com uma heurística nula (equivalente a busca de custo uniforme) deve encontrar uma solução para o problema test\+Search sem nenhuma mudança no código (custo total de 7).


\begin{DoxyCode}
python pacman.py -l testSearch -p AStarFoodSearchAgent
\end{DoxyCode}


{\itshape Nota\+:} {\ttfamily A\+Star\+Food\+Search\+Agent} é um atalho para {\ttfamily -\/p Search\+Agent -\/a fn=astar,prob=Food\+Search\+Problem,heuristic=food\+Heuristic}. Porém, a busca de custo uniforme fica lenta até para problemas simples como {\ttfamily tiny\+Search}.

\subsection*{Etapa 5 (2 pontos)}

Implemente uma heurística admissível {\ttfamily food\+Heuristic} no arquivo {\ttfamily search\+Agents.\+py} para o problema {\ttfamily Food\+Search\+Problem}. Teste seu agente no problema {\ttfamily tricky\+Search}\+:


\begin{DoxyCode}
python pacman.py -l trickySearch -p AStarFoodSearchAgent
\end{DoxyCode}
 \section*{Glossário}

Este é um glossário dos objetos principais na base de código relacionada a problemas de busca\+:


\begin{DoxyItemize}
\item {\ttfamily Search\+Problem} ({\ttfamily search.\+py})\+: Um {\ttfamily Search\+Problem} é um objeto abstrato que representa o espaço de estados, função sucessora, custos, e estado objetivo de um problema. Você vai interagir com objetos do tipo {\ttfamily Search\+Problem} somente através dos métodos definidos no topo de {\ttfamily search.\+py}.
\item {\ttfamily Position\+Search\+Problem} ({\ttfamily search\+Agents.\+py})\+: Um tipo específico de {\ttfamily Search\+Problem} --- corresponde a procurar por uma única comida no labirinto.
\item {\ttfamily Food\+Search\+Problem} ({\ttfamily search\+Agents.\+py})\+: Um tipo específico de {\ttfamily Search\+Problem} --- corresponde a procurar um caminho para comer toda a comida em um labirinto.
\item {\bfseries Função de Busca\+:} Uma função de busca é uma função que recebe como entrada uma instância de {\ttfamily Search\+Problem}, roda algum algoritmo, e retorna a sequência de ações que levam ao objetivo. Exemplos de função de busca são {\ttfamily depth\+First\+Search} e {\ttfamily breadth\+First\+Search}, que deverão ser escritas pelo grupo. A função de busca dada {\ttfamily tiny\+Maze\+Search} é uma função muito ruim que só funciona para o labirinto {\ttfamily tiny\+Maze}.
\item {\ttfamily Search\+Agent}\+: é uma classe que implementa um agente (um objeto que interage com o mundo) e faz seu planejamento de acordo com uma função de busca. {\ttfamily Search\+Agent} primeiro usa uma função de busca para encontrar uma sequência de ações que levem ao estado objetivo, e depois executa as ações uma por vez. 
\end{DoxyItemize}